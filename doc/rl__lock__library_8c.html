<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rl-lock-library: rl_lock_library.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rl-lock-library
   </div>
   <div id="projectbrief">Improved POSIX region locking mechanism</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rl_lock_library.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;sys/file.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &quot;<a class="el" href="rl__lock__library_8h_source.html">rl_lock_library.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a78c99ffd76a7bb3c8c74db76207e9ab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a78c99ffd76a7bb3c8c74db76207e9ab4">_XOPEN_SOURCE</a>&#160;&#160;&#160;500</td></tr>
<tr class="separator:a78c99ffd76a7bb3c8c74db76207e9ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3024ccd4a9af5109d24e6c57565d74a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a3024ccd4a9af5109d24e6c57565d74a1">_POSIX_C_SOURCE</a>&#160;&#160;&#160;200112L</td></tr>
<tr class="separator:a3024ccd4a9af5109d24e6c57565d74a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28c1a2722e49a9db54b51496719b977a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a28c1a2722e49a9db54b51496719b977a">initialize_mutex</a> (pthread_mutex_t *pmutex)</td></tr>
<tr class="memdesc:a28c1a2722e49a9db54b51496719b977a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code>pmutex</code> for process sync.  <a href="rl__lock__library_8c.html#a28c1a2722e49a9db54b51496719b977a">More...</a><br /></td></tr>
<tr class="separator:a28c1a2722e49a9db54b51496719b977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9e849282179f01fdad17192b48109d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a1f9e849282179f01fdad17192b48109d">is_owner_free</a> (<a class="el" href="structrl__owner.html">rl_owner</a> *owner)</td></tr>
<tr class="memdesc:a1f9e849282179f01fdad17192b48109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>owner</code> is free.  <a href="rl__lock__library_8c.html#a1f9e849282179f01fdad17192b48109d">More...</a><br /></td></tr>
<tr class="separator:a1f9e849282179f01fdad17192b48109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38bf7e4a7303b7b421540113da7d3b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#ab38bf7e4a7303b7b421540113da7d3b6">erase_owner</a> (<a class="el" href="structrl__owner.html">rl_owner</a> *owner)</td></tr>
<tr class="memdesc:ab38bf7e4a7303b7b421540113da7d3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases <code>owner</code> if possible.  <a href="rl__lock__library_8c.html#ab38bf7e4a7303b7b421540113da7d3b6">More...</a><br /></td></tr>
<tr class="separator:ab38bf7e4a7303b7b421540113da7d3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f15932440812686e0921becb723a7b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#ae3f15932440812686e0921becb723a7b">organize_owners</a> (<a class="el" href="structrl__lock.html">rl_lock</a> *lck)</td></tr>
<tr class="memdesc:ae3f15932440812686e0921becb723a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the owners of <code>lck</code> in order to fit in the first <code>lck-&gt;nb_owners</code> cells of <code>lck</code> owner table.  <a href="rl__lock__library_8c.html#ae3f15932440812686e0921becb723a7b">More...</a><br /></td></tr>
<tr class="separator:ae3f15932440812686e0921becb723a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a211c1508ac0ecc6bc9593cf140ed1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a31a211c1508ac0ecc6bc9593cf140ed1">equals</a> (<a class="el" href="structrl__owner.html">rl_owner</a> o1, <a class="el" href="structrl__owner.html">rl_owner</a> o2)</td></tr>
<tr class="memdesc:a31a211c1508ac0ecc6bc9593cf140ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the owners are equal.  <a href="rl__lock__library_8c.html#a31a211c1508ac0ecc6bc9593cf140ed1">More...</a><br /></td></tr>
<tr class="separator:a31a211c1508ac0ecc6bc9593cf140ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84eb80c9f6a88a274c6376cfeca0e05"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#ae84eb80c9f6a88a274c6376cfeca0e05">erase_lock</a> (<a class="el" href="structrl__lock.html">rl_lock</a> *lck)</td></tr>
<tr class="memdesc:ae84eb80c9f6a88a274c6376cfeca0e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases <code>lck</code> if possible.  <a href="rl__lock__library_8c.html#ae84eb80c9f6a88a274c6376cfeca0e05">More...</a><br /></td></tr>
<tr class="separator:ae84eb80c9f6a88a274c6376cfeca0e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33726e1d20125f446dca243b77705192"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a33726e1d20125f446dca243b77705192">is_lock_free</a> (<a class="el" href="structrl__lock.html">rl_lock</a> *lck)</td></tr>
<tr class="memdesc:a33726e1d20125f446dca243b77705192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>lck</code> is free.  <a href="rl__lock__library_8c.html#a33726e1d20125f446dca243b77705192">More...</a><br /></td></tr>
<tr class="separator:a33726e1d20125f446dca243b77705192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5617fe59ceaeb0028f2a9ac1009e99"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a6a5617fe59ceaeb0028f2a9ac1009e99">organize_locks</a> (<a class="el" href="structrl__open__file.html">rl_open_file</a> *file)</td></tr>
<tr class="memdesc:a6a5617fe59ceaeb0028f2a9ac1009e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the locks of <code>file</code> in order to fit in the first <code>file-&gt;nb_locks</code> cells of <code>file</code> lock table.  <a href="rl__lock__library_8c.html#a6a5617fe59ceaeb0028f2a9ac1009e99">More...</a><br /></td></tr>
<tr class="separator:a6a5617fe59ceaeb0028f2a9ac1009e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf22f0d7aade249af5cc97d781435d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a8cf22f0d7aade249af5cc97d781435d9">rl_lock_to_flock</a> (const <a class="el" href="structrl__lock.html">rl_lock</a> *from, struct flock *to)</td></tr>
<tr class="memdesc:a8cf22f0d7aade249af5cc97d781435d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>from</code> into a <code>struct flock</code> and puts the result in <code>to</code>  <a href="rl__lock__library_8c.html#a8cf22f0d7aade249af5cc97d781435d9">More...</a><br /></td></tr>
<tr class="separator:a8cf22f0d7aade249af5cc97d781435d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cb58f90252edea92d24b3225e5c71a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#ae5cb58f90252edea92d24b3225e5c71a">delete_owner_on_criteria</a> (<a class="el" href="structrl__open__file.html">rl_open_file</a> *file, int(*crit)(<a class="el" href="structrl__owner.html">rl_owner</a>, <a class="el" href="structrl__owner.html">rl_owner</a>), <a class="el" href="structrl__owner.html">rl_owner</a> owner_crit)</td></tr>
<tr class="memdesc:ae5cb58f90252edea92d24b3225e5c71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes every owner that matches the given criteria in the given file.  <a href="rl__lock__library_8c.html#ae5cb58f90252edea92d24b3225e5c71a">More...</a><br /></td></tr>
<tr class="separator:ae5cb58f90252edea92d24b3225e5c71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69d34a4647830488b031d77488e4f0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#ad69d34a4647830488b031d77488e4f0f">rl_close</a> (<a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd)</td></tr>
<tr class="memdesc:ad69d34a4647830488b031d77488e4f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the given locked file descriptor.  <a href="rl__lock__library_8c.html#ad69d34a4647830488b031d77488e4f0f">More...</a><br /></td></tr>
<tr class="separator:ad69d34a4647830488b031d77488e4f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c6efb15dd77951ca68fbd34d4d635"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a763c6efb15dd77951ca68fbd34d4d635">rl_init_library</a> ()</td></tr>
<tr class="memdesc:a763c6efb15dd77951ca68fbd34d4d635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the library.  <a href="rl__lock__library_8c.html#a763c6efb15dd77951ca68fbd34d4d635">More...</a><br /></td></tr>
<tr class="separator:a763c6efb15dd77951ca68fbd34d4d635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797818ab26aa899d17abbeabd1f089e5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a797818ab26aa899d17abbeabd1f089e5">add_to_rla</a> (<a class="el" href="structrl__open__file.html">rl_open_file</a> *rlo)</td></tr>
<tr class="memdesc:a797818ab26aa899d17abbeabd1f089e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given open file to the open file descriptions of this process.  <a href="rl__lock__library_8c.html#a797818ab26aa899d17abbeabd1f089e5">More...</a><br /></td></tr>
<tr class="separator:a797818ab26aa899d17abbeabd1f089e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207217b5b8abd21392ded570ac296b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a207217b5b8abd21392ded570ac296b72">rl_open</a> (const char *path, int oflag,...)</td></tr>
<tr class="memdesc:a207217b5b8abd21392ded570ac296b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the file at the given path.  <a href="rl__lock__library_8c.html#a207217b5b8abd21392ded570ac296b72">More...</a><br /></td></tr>
<tr class="separator:a207217b5b8abd21392ded570ac296b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92d543f922ba6d6495b29e460a5add7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#ad92d543f922ba6d6495b29e460a5add7">seg_overlap</a> (off_t s1, off_t l1, off_t s2, off_t l2)</td></tr>
<tr class="memdesc:ad92d543f922ba6d6495b29e460a5add7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the segment [s1, s1 + l1[ and [s2, s2 + l2[ overlap.  <a href="rl__lock__library_8c.html#ad92d543f922ba6d6495b29e460a5add7">More...</a><br /></td></tr>
<tr class="separator:ad92d543f922ba6d6495b29e460a5add7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbda51a499e68faf42faa5e1ac03f5f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#abdbda51a499e68faf42faa5e1ac03f5f">has_different_owner</a> (const <a class="el" href="structrl__lock.html">rl_lock</a> *lock, <a class="el" href="structrl__owner.html">rl_owner</a> owner)</td></tr>
<tr class="memdesc:abdbda51a499e68faf42faa5e1ac03f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the lock is owned by an <a class="el" href="structrl__owner.html" title="The owner of a locked segment.">rl_owner</a> different than owner.  <a href="rl__lock__library_8c.html#abdbda51a499e68faf42faa5e1ac03f5f">More...</a><br /></td></tr>
<tr class="separator:abdbda51a499e68faf42faa5e1ac03f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a4d7699b61661b084fbf1206c1033f"><td class="memItemLeft" align="right" valign="top">static off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a68a4d7699b61661b084fbf1206c1033f">get_start</a> (struct flock *lck, int fd)</td></tr>
<tr class="memdesc:a68a4d7699b61661b084fbf1206c1033f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the starting offset of the lock of the file denoted by fd.  <a href="rl__lock__library_8c.html#a68a4d7699b61661b084fbf1206c1033f">More...</a><br /></td></tr>
<tr class="separator:a68a4d7699b61661b084fbf1206c1033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6f8ef8d172e6328c74ce0ccfc976a"><td class="memItemLeft" align="right" valign="top">static pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a54c6f8ef8d172e6328c74ce0ccfc976a">is_lock_applicable</a> (struct flock *lck, <a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd)</td></tr>
<tr class="memdesc:a54c6f8ef8d172e6328c74ce0ccfc976a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given lock can be put on the given descriptor.  <a href="rl__lock__library_8c.html#a54c6f8ef8d172e6328c74ce0ccfc976a">More...</a><br /></td></tr>
<tr class="separator:a54c6f8ef8d172e6328c74ce0ccfc976a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ad86cfb756d4d1f805d8664bda7d04"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a15ad86cfb756d4d1f805d8664bda7d04">same_pid</a> (<a class="el" href="structrl__owner.html">rl_owner</a> ol, <a class="el" href="structrl__owner.html">rl_owner</a> or)</td></tr>
<tr class="memdesc:a15ad86cfb756d4d1f805d8664bda7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>ol</code> and <code>or</code> have the same PID.  <a href="rl__lock__library_8c.html#a15ad86cfb756d4d1f805d8664bda7d04">More...</a><br /></td></tr>
<tr class="separator:a15ad86cfb756d4d1f805d8664bda7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485bf4ae16714b4120ba771fe37ad80b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a485bf4ae16714b4120ba771fe37ad80b">remove_locks_of</a> (pid_t pid, <a class="el" href="structrl__open__file.html">rl_open_file</a> *file)</td></tr>
<tr class="memdesc:a485bf4ae16714b4120ba771fe37ad80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the locks owned by the process of given PID in the given <a class="el" href="structrl__open__file.html" title="The locks on an open file description.">rl_open_file</a>.  <a href="rl__lock__library_8c.html#a485bf4ae16714b4120ba771fe37ad80b">More...</a><br /></td></tr>
<tr class="separator:a485bf4ae16714b4120ba771fe37ad80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493fae56133f7da81635eb3630fbca92"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a493fae56133f7da81635eb3630fbca92">add_owner</a> (<a class="el" href="structrl__owner.html">rl_owner</a> new, <a class="el" href="structrl__lock.html">rl_lock</a> *lck)</td></tr>
<tr class="memdesc:a493fae56133f7da81635eb3630fbca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>new</code> to the owners table of <code>lck</code> if possible.  <a href="rl__lock__library_8c.html#a493fae56133f7da81635eb3630fbca92">More...</a><br /></td></tr>
<tr class="separator:a493fae56133f7da81635eb3630fbca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe54cfc3530e606c153dc83837db7b8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#acbe54cfc3530e606c153dc83837db7b8">is_owner_of</a> (<a class="el" href="structrl__owner.html">rl_owner</a> owner, <a class="el" href="structrl__lock.html">rl_lock</a> *lck)</td></tr>
<tr class="memdesc:acbe54cfc3530e606c153dc83837db7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>owner</code> is an owner of <code>lck</code>  <a href="rl__lock__library_8c.html#acbe54cfc3530e606c153dc83837db7b8">More...</a><br /></td></tr>
<tr class="separator:acbe54cfc3530e606c153dc83837db7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8958b4904e83b24cb20c9a5c5a04d04e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a8958b4904e83b24cb20c9a5c5a04d04e">add_lock</a> (<a class="el" href="structrl__lock.html">rl_lock</a> *new, <a class="el" href="structrl__open__file.html">rl_open_file</a> *file, <a class="el" href="structrl__owner.html">rl_owner</a> first)</td></tr>
<tr class="memdesc:a8958b4904e83b24cb20c9a5c5a04d04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>new</code> to the locks of <code>file</code> if possible, where <code>first</code> is the initial owner of <code>new</code>  <a href="rl__lock__library_8c.html#a8958b4904e83b24cb20c9a5c5a04d04e">More...</a><br /></td></tr>
<tr class="separator:a8958b4904e83b24cb20c9a5c5a04d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8944e99bc29a2a0c3caa14e05c130b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#acd8944e99bc29a2a0c3caa14e05c130b">find_lock</a> (<a class="el" href="structrl__open__file.html">rl_open_file</a> *file, <a class="el" href="structrl__lock.html">rl_lock</a> *lck)</td></tr>
<tr class="memdesc:acd8944e99bc29a2a0c3caa14e05c130b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lock in <code>file</code> that starts at the same offset, has the same length and is of the same type than <code>lck</code>  <a href="rl__lock__library_8c.html#acd8944e99bc29a2a0c3caa14e05c130b">More...</a><br /></td></tr>
<tr class="separator:acd8944e99bc29a2a0c3caa14e05c130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5624a83e0f351e7c0b791e23138b0502"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a5624a83e0f351e7c0b791e23138b0502">apply_unlock</a> (<a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd, struct flock *lck)</td></tr>
<tr class="memdesc:a5624a83e0f351e7c0b791e23138b0502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the region delimited by <code>lck</code> of the open file pointed by <code>lfd</code>  <a href="rl__lock__library_8c.html#a5624a83e0f351e7c0b791e23138b0502">More...</a><br /></td></tr>
<tr class="separator:a5624a83e0f351e7c0b791e23138b0502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb901c0da6b11c8655f21d9acc5b64b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#addb901c0da6b11c8655f21d9acc5b64b">apply_rw_lock</a> (<a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd, struct flock *lck)</td></tr>
<tr class="memdesc:addb901c0da6b11c8655f21d9acc5b64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the region specified by <code>lck</code> of the open file pointed by <code>lfd</code>  <a href="rl__lock__library_8c.html#addb901c0da6b11c8655f21d9acc5b64b">More...</a><br /></td></tr>
<tr class="separator:addb901c0da6b11c8655f21d9acc5b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef90388f848993be176bc56b3ec2c81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#acef90388f848993be176bc56b3ec2c81">rl_fcntl</a> (<a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd, int cmd, struct flock *lck)</td></tr>
<tr class="separator:acef90388f848993be176bc56b3ec2c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df90778abd49050b791bbfcdbf911c1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a0df90778abd49050b791bbfcdbf911c1">dup_owner</a> (<a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd, <a class="el" href="structrl__owner.html">rl_owner</a> new_owner)</td></tr>
<tr class="memdesc:a0df90778abd49050b791bbfcdbf911c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new_owner as a lock owner of every lock where <code>lfd_owner = {.pid = getpid(), .fd = lfd.fd}</code> is also an owner.  <a href="rl__lock__library_8c.html#a0df90778abd49050b791bbfcdbf911c1">More...</a><br /></td></tr>
<tr class="separator:a0df90778abd49050b791bbfcdbf911c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d722168e425a38c06a8e6be7bbb02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#adc2d722168e425a38c06a8e6be7bbb02">rl_dup</a> (<a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd)</td></tr>
<tr class="memdesc:adc2d722168e425a38c06a8e6be7bbb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates <code>lfd</code> using the lowest numbered available file descriptor.  <a href="rl__lock__library_8c.html#adc2d722168e425a38c06a8e6be7bbb02">More...</a><br /></td></tr>
<tr class="separator:adc2d722168e425a38c06a8e6be7bbb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa96dfcf21afde9089cd8edc330eba2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#aaa96dfcf21afde9089cd8edc330eba2f">rl_dup2</a> (<a class="el" href="structrl__descriptor.html">rl_descriptor</a> lfd, int new_fd)</td></tr>
<tr class="memdesc:aaa96dfcf21afde9089cd8edc330eba2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates <code>lfd</code> using <code>new_fd</code>  <a href="rl__lock__library_8c.html#aaa96dfcf21afde9089cd8edc330eba2f">More...</a><br /></td></tr>
<tr class="separator:aaa96dfcf21afde9089cd8edc330eba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14eee1b45976eac0d2705ec7b41cebf1"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a14eee1b45976eac0d2705ec7b41cebf1">rl_fork</a> ()</td></tr>
<tr class="separator:a14eee1b45976eac0d2705ec7b41cebf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9780efefa833de742e5421564d25fe70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#a9780efefa833de742e5421564d25fe70">rl_print_open_file</a> (<a class="el" href="structrl__open__file.html">rl_open_file</a> *file, int display_pids)</td></tr>
<tr class="memdesc:a9780efefa833de742e5421564d25fe70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an <code><a class="el" href="structrl__open__file.html" title="The locks on an open file description.">rl_open_file</a></code> to standard output.  <a href="rl__lock__library_8c.html#a9780efefa833de742e5421564d25fe70">More...</a><br /></td></tr>
<tr class="separator:a9780efefa833de742e5421564d25fe70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad8a2351101b46c8c1e323595e506259f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrl__all__files.html">rl_all_files</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rl__lock__library_8c.html#ad8a2351101b46c8c1e323595e506259f">rla</a></td></tr>
<tr class="memdesc:ad8a2351101b46c8c1e323595e506259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the file descriptions opened by this process.  <a href="rl__lock__library_8c.html#ad8a2351101b46c8c1e323595e506259f">More...</a><br /></td></tr>
<tr class="separator:ad8a2351101b46c8c1e323595e506259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3024ccd4a9af5109d24e6c57565d74a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3024ccd4a9af5109d24e6c57565d74a1">&#9670;&nbsp;</a></span>_POSIX_C_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _POSIX_C_SOURCE&#160;&#160;&#160;200112L</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78c99ffd76a7bb3c8c74db76207e9ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c99ffd76a7bb3c8c74db76207e9ab4">&#9670;&nbsp;</a></span>_XOPEN_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _XOPEN_SOURCE&#160;&#160;&#160;500</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8958b4904e83b24cb20c9a5c5a04d04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8958b4904e83b24cb20c9a5c5a04d04e">&#9670;&nbsp;</a></span>add_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int add_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__open__file.html">rl_open_file</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>new</code> to the locks of <code>file</code> if possible, where <code>first</code> is the initial owner of <code>new</code> </p>
<p>This function should be use when <code>new</code> is not already a lock of <code>file</code>. The owners that might be stored in <code>new</code> are erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new</td><td>the lock to add </td></tr>
    <tr><td class="paramname">file</td><td>the file in which to add <code>new</code> </td></tr>
    <tr><td class="paramname">first</td><td>the initial owner of <code>new</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a493fae56133f7da81635eb3630fbca92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493fae56133f7da81635eb3630fbca92">&#9670;&nbsp;</a></span>add_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int add_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>lck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>new</code> to the owners table of <code>lck</code> if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new</td><td>the owner to add </td></tr>
    <tr><td class="paramname">lck</td><td>the lock to which to add the new owner </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if <code>new</code> was succesfully added, -1 if it could not be added </dd></dl>

</div>
</div>
<a id="a797818ab26aa899d17abbeabd1f089e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797818ab26aa899d17abbeabd1f089e5">&#9670;&nbsp;</a></span>add_to_rla()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int add_to_rla </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__open__file.html">rl_open_file</a> *&#160;</td>
          <td class="paramname"><em>rlo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given open file to the open file descriptions of this process. </p>
<p>Fails if rla is full.</p>
<p>@parm rlo the open file to add </p><dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="addb901c0da6b11c8655f21d9acc5b64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb901c0da6b11c8655f21d9acc5b64b">&#9670;&nbsp;</a></span>apply_rw_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int apply_rw_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct flock *&#160;</td>
          <td class="paramname"><em>lck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the region specified by <code>lck</code> of the open file pointed by <code>lfd</code> </p>
<p>The region to lock must be finite (not extensible) and must start at or after the beginning of the file. This function does not use any locking mechanism, ensure mutual exclusion before the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfd</td><td>the file descriptor to lock </td></tr>
    <tr><td class="paramname">lck</td><td>the region to lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="a5624a83e0f351e7c0b791e23138b0502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5624a83e0f351e7c0b791e23138b0502">&#9670;&nbsp;</a></span>apply_unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int apply_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct flock *&#160;</td>
          <td class="paramname"><em>lck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the region delimited by <code>lck</code> of the open file pointed by <code>lfd</code> </p>
<p><code>lck</code> must be of type <code>F_UNLCK</code>, the region to lock must be finite (not extensible) and must start at or after the beginning of the file. This function does not use any locking mechanism, ensure mutual exclusion before the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfd</td><td>the file descriptor to unlock </td></tr>
    <tr><td class="paramname">lck</td><td>the region to unlock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="ae5cb58f90252edea92d24b3225e5c71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cb58f90252edea92d24b3225e5c71a">&#9670;&nbsp;</a></span>delete_owner_on_criteria()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int delete_owner_on_criteria </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__open__file.html">rl_open_file</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(<a class="el" href="structrl__owner.html">rl_owner</a>, <a class="el" href="structrl__owner.html">rl_owner</a>)&#160;</td>
          <td class="paramname"><em>crit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>owner_crit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes every owner that matches the given criteria in the given file. </p>
<p>This function does not use any locking mechanism. If <code>crit</code> returns a value </p><blockquote class="doxtable">
<p>0, the owner given as first parameter of the function is erased from the </p>
</blockquote>
<p>lock owners table of the currently considered lock of the file. If <code>crit</code> returns 0, nothing is done. If it returns -1, the function quits on error. After each removal, the owners in the lock owner table are reorganized, so as the locks if there are no owners left.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file that contains the lock owners to remove </td></tr>
    <tr><td class="paramname">crit</td><td>a function that take two lock owners and returns an integer </td></tr>
    <tr><td class="paramname">owner_crit</td><td>the owner used as second parameter of <code>crit</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the owner removal was succesful, -1 on error. </dd></dl>

</div>
</div>
<a id="a0df90778abd49050b791bbfcdbf911c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df90778abd49050b791bbfcdbf911c1">&#9670;&nbsp;</a></span>dup_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int dup_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>new_owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds new_owner as a lock owner of every lock where <code>lfd_owner = {.pid = getpid(), .fd = lfd.fd}</code> is also an owner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfd</td><td>the file descriptor where to add <code>new_owner</code> </td></tr>
    <tr><td class="paramname">new_owner</td><td>the owner to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="a31a211c1508ac0ecc6bc9593cf140ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a211c1508ac0ecc6bc9593cf140ed1">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>o1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>o2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the owners are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o1</td><td>the first owner </td></tr>
    <tr><td class="paramname">o2</td><td>the second owner </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if they are equal, that is if o1.pid == o2.pid &amp;&amp; o1.fd == o2.fd, 0 otherwise </dd></dl>

</div>
</div>
<a id="ae84eb80c9f6a88a274c6376cfeca0e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84eb80c9f6a88a274c6376cfeca0e05">&#9670;&nbsp;</a></span>erase_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void erase_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>lck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases <code>lck</code> if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lck</td><td>the lock to erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab38bf7e4a7303b7b421540113da7d3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38bf7e4a7303b7b421540113da7d3b6">&#9670;&nbsp;</a></span>erase_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void erase_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a> *&#160;</td>
          <td class="paramname"><em>owner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases <code>owner</code> if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the owner to erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd8944e99bc29a2a0c3caa14e05c130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8944e99bc29a2a0c3caa14e05c130b">&#9670;&nbsp;</a></span>find_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrl__lock.html">rl_lock</a>* find_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__open__file.html">rl_open_file</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>lck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the lock in <code>file</code> that starts at the same offset, has the same length and is of the same type than <code>lck</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file that might contain <code>lck</code> </td></tr>
    <tr><td class="paramname">lck</td><td>the lock to find in <code>file</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding lock in file or NULL if it was not found </dd></dl>

</div>
</div>
<a id="a68a4d7699b61661b084fbf1206c1033f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a4d7699b61661b084fbf1206c1033f">&#9670;&nbsp;</a></span>get_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static off_t get_start </td>
          <td>(</td>
          <td class="paramtype">struct flock *&#160;</td>
          <td class="paramname"><em>lck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the starting offset of the lock of the file denoted by fd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lck</td><td>a lock on a region </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor of the file to lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the starting offset of the region or -1 if it could not be determined </dd></dl>

</div>
</div>
<a id="abdbda51a499e68faf42faa5e1ac03f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbda51a499e68faf42faa5e1ac03f5f">&#9670;&nbsp;</a></span>has_different_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int has_different_owner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the lock is owned by an <a class="el" href="structrl__owner.html" title="The owner of a locked segment.">rl_owner</a> different than owner. </p>
<p>This function does not use any locking mechanism to secure the access to lock, nor tests if owner is in fact an owner of lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>the lock to check </td></tr>
    <tr><td class="paramname">owner</td><td>the owner to compare the lock owners with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lock is owned by a different owner, 0 otherwise </dd></dl>

</div>
</div>
<a id="a28c1a2722e49a9db54b51496719b977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c1a2722e49a9db54b51496719b977a">&#9670;&nbsp;</a></span>initialize_mutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int initialize_mutex </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code>pmutex</code> for process sync. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmutex</td><td>the mutex to initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the initialization was successfull, the error code otherwise </dd></dl>

</div>
</div>
<a id="a54c6f8ef8d172e6328c74ce0ccfc976a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c6f8ef8d172e6328c74ce0ccfc976a">&#9670;&nbsp;</a></span>is_lock_applicable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pid_t is_lock_applicable </td>
          <td>(</td>
          <td class="paramtype">struct flock *&#160;</td>
          <td class="paramname"><em>lck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given lock can be put on the given descriptor. </p>
<p>This function only checks for conflicting locks, it doesn't verify if the lock table is big enough for the new locks. This is done in other functions. This function does not use any locking mechanism, so be sure to take the lock before entering this function in order to verify mutual exclusion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lck</td><td>the lock to put </td></tr>
    <tr><td class="paramname">lfd</td><td>the file on which to put the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lock is applicable, 0 if it is not, -1 if an error occured. If the lock is not applicable because of a lock put by a process that has died and has not removed its locks, returns the pid of that process. </dd></dl>

</div>
</div>
<a id="a33726e1d20125f446dca243b77705192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33726e1d20125f446dca243b77705192">&#9670;&nbsp;</a></span>is_lock_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int is_lock_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>lck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>lck</code> is free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lck</td><td>the lock to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if <code>lck</code> is free, 0 otherwise </dd></dl>

</div>
</div>
<a id="a1f9e849282179f01fdad17192b48109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9e849282179f01fdad17192b48109d">&#9670;&nbsp;</a></span>is_owner_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int is_owner_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a> *&#160;</td>
          <td class="paramname"><em>owner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>owner</code> is free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the owner to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is free, 0 otherwise </dd></dl>

</div>
</div>
<a id="acbe54cfc3530e606c153dc83837db7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe54cfc3530e606c153dc83837db7b8">&#9670;&nbsp;</a></span>is_owner_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int is_owner_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>lck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>owner</code> is an owner of <code>lck</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the owner that might own <code>lck</code> </td></tr>
    <tr><td class="paramname">lck</td><td>the lock that might be owned by <code>owner</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if <code>owner</code> is an owner of <code>lck</code>, 0 if it is not </dd></dl>

</div>
</div>
<a id="a6a5617fe59ceaeb0028f2a9ac1009e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5617fe59ceaeb0028f2a9ac1009e99">&#9670;&nbsp;</a></span>organize_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int organize_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__open__file.html">rl_open_file</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the locks of <code>file</code> in order to fit in the first <code>file-&gt;nb_locks</code> cells of <code>file</code> lock table. </p>
<p>This function does not use any locking mechanism, so be sure to have an exclusive lock on the structure before organizing its lock in order to preserve data integrity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file that contains the locks to organize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the locks were successfully organized, -1 on error </dd></dl>

</div>
</div>
<a id="ae3f15932440812686e0921becb723a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f15932440812686e0921becb723a7b">&#9670;&nbsp;</a></span>organize_owners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int organize_owners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>lck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the owners of <code>lck</code> in order to fit in the first <code>lck-&gt;nb_owners</code> cells of <code>lck</code> owner table. </p>
<p>This function does not use any locking mechanism, so be sure to have an exclusive lock on the structure before organizing its owners in order to preserve data integrity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lck</td><td>the lck that contains the owners to organize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the owners were successfully organized, -1 on error </dd></dl>

</div>
</div>
<a id="a485bf4ae16714b4120ba771fe37ad80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485bf4ae16714b4120ba771fe37ad80b">&#9670;&nbsp;</a></span>remove_locks_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int remove_locks_of </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__open__file.html">rl_open_file</a> *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the locks owned by the process of given PID in the given <a class="el" href="structrl__open__file.html" title="The locks on an open file description.">rl_open_file</a>. </p>
<p>This function does not use any locking mechanism, be sure that mutual exclusion is assured before using it. If after removal a lock is empty, it is also deleted. The owners of every modified lock are reorganized, so as the locks of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>the PID of the process that owns the locks to remove </td></tr>
    <tr><td class="paramname">file</td><td>the file that contains the locks to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="ad69d34a4647830488b031d77488e4f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69d34a4647830488b031d77488e4f0f">&#9670;&nbsp;</a></span>rl_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rl_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the given locked file descriptor. </p>
<p>This function removes from each lock of the descripted open file the owner <code>{getpid(), lfd.fd}</code> if present. After deletion, the lock owners of each lock are reorganized, as each lock of the lock table of the open file description. The <code>close()</code> operation is made only if the previous operations are successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfd</td><td>the locked file descriptor to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if <code>lfd</code> was successfully closed, -1 on error </dd></dl>

</div>
</div>
<a id="adc2d722168e425a38c06a8e6be7bbb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2d722168e425a38c06a8e6be7bbb02">&#9670;&nbsp;</a></span>rl_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrl__descriptor.html">rl_descriptor</a> rl_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates <code>lfd</code> using the lowest numbered available file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfd</td><td>the locked file description to duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a duplication of <code>lfd</code> on success, {.fd = -1, .file = NULL} on error </dd></dl>

</div>
</div>
<a id="aaa96dfcf21afde9089cd8edc330eba2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa96dfcf21afde9089cd8edc330eba2f">&#9670;&nbsp;</a></span>rl_dup2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrl__descriptor.html">rl_descriptor</a> rl_dup2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates <code>lfd</code> using <code>new_fd</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfd</td><td>the locked file description to duplicate </td></tr>
    <tr><td class="paramname">new_fd</td><td>the open file description to use for the duplication </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>{.fd = new_fd, .file = lfd.file} on success, {.fd = -1, .file = NULL} on error </dd></dl>

</div>
</div>
<a id="acef90388f848993be176bc56b3ec2c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef90388f848993be176bc56b3ec2c81">&#9670;&nbsp;</a></span>rl_fcntl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rl_fcntl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__descriptor.html">rl_descriptor</a>&#160;</td>
          <td class="paramname"><em>lfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct flock *&#160;</td>
          <td class="paramname"><em>lck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfd</td><td></td></tr>
    <tr><td class="paramname">cmd</td><td></td></tr>
    <tr><td class="paramname">lck</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a14eee1b45976eac0d2705ec7b41cebf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eee1b45976eac0d2705ec7b41cebf1">&#9670;&nbsp;</a></span>rl_fork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t rl_fork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a763c6efb15dd77951ca68fbd34d4d635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c6efb15dd77951ca68fbd34d4d635">&#9670;&nbsp;</a></span>rl_init_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rl_init_library </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the library. </p>
<p>You must call this function before using the library.</p>
<dl class="section return"><dt>Returns</dt><dd>always 0 </dd></dl>

</div>
</div>
<a id="a8cf22f0d7aade249af5cc97d781435d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf22f0d7aade249af5cc97d781435d9">&#9670;&nbsp;</a></span>rl_lock_to_flock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rl_lock_to_flock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrl__lock.html">rl_lock</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct flock *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>from</code> into a <code>struct flock</code> and puts the result in <code>to</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the original <code><a class="el" href="structrl__lock.html" title="The locked segment of a file.">rl_lock</a></code> </td></tr>
    <tr><td class="paramname">to</td><td>the conversion of <code>from</code> to a <code>struct flock</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="a207217b5b8abd21392ded570ac296b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207217b5b8abd21392ded570ac296b72">&#9670;&nbsp;</a></span>rl_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrl__descriptor.html">rl_descriptor</a> rl_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the file at the given path. </p>
<p>Opens <code>path</code> with the open() system call (identical parameters). Also does the memory projection of the <code><a class="el" href="structrl__open__file.html" title="The locks on an open file description.">rl_open_file</a></code> associated with the file at path, creating the shared memory object if it doesn't exist. Returns the corresponding <code><a class="el" href="structrl__descriptor.html" title="The open file description.">rl_descriptor</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the relative or absolute path to the file </td></tr>
    <tr><td class="paramname">oflag</td><td>the flags passed to <code>open()</code> </td></tr>
    <tr><td class="paramname">...</td><td>the mode (permissions) for the new file, required if O_CREAT flag is specified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structrl__descriptor.html" title="The open file description.">rl_descriptor</a> containing the file descriptor returned by open() and a pointer to the <a class="el" href="structrl__open__file.html" title="The locks on an open file description.">rl_open_file</a> associated to the file, or an <a class="el" href="structrl__descriptor.html" title="The open file description.">rl_descriptor</a> containing fd -1 and <a class="el" href="structrl__open__file.html" title="The locks on an open file description.">rl_open_file</a> pointer NULL on error </dd></dl>

</div>
</div>
<a id="a9780efefa833de742e5421564d25fe70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9780efefa833de742e5421564d25fe70">&#9670;&nbsp;</a></span>rl_print_open_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rl_print_open_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__open__file.html">rl_open_file</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>display_pids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an <code><a class="el" href="structrl__open__file.html" title="The locks on an open file description.">rl_open_file</a></code> to standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the open file to print </td></tr>
    <tr><td class="paramname">display_pids</td><td>whether to print owner PIDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="a15ad86cfb756d4d1f805d8664bda7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ad86cfb756d4d1f805d8664bda7d04">&#9670;&nbsp;</a></span>same_pid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int same_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>ol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl__owner.html">rl_owner</a>&#160;</td>
          <td class="paramname"><em>or</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>ol</code> and <code>or</code> have the same PID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ol</td><td>the left owner </td></tr>
    <tr><td class="paramname">or</td><td>the right owner </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if <code>ol</code> and <code>or</code> have the same PID, 0 otherwise </dd></dl>

</div>
</div>
<a id="ad92d543f922ba6d6495b29e460a5add7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92d543f922ba6d6495b29e460a5add7">&#9670;&nbsp;</a></span>seg_overlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int seg_overlap </td>
          <td>(</td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the segment [s1, s1 + l1[ and [s2, s2 + l2[ overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the start of the first segment </td></tr>
    <tr><td class="paramname">l1</td><td>the length of the first segment </td></tr>
    <tr><td class="paramname">s2</td><td>the start of the second segment </td></tr>
    <tr><td class="paramname">l2</td><td>the length of the second segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the segments overlap, 0 otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad8a2351101b46c8c1e323595e506259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a2351101b46c8c1e323595e506259f">&#9670;&nbsp;</a></span>rla</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrl__all__files.html">rl_all_files</a> rla</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All the file descriptions opened by this process. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
